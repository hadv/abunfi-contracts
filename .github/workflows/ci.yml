name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  FOUNDRY_PROFILE: ci
  FOUNDRY_DISABLE_NIGHTLY_WARNING: true
  FOUNDRY_CACHE_PATH: ~/.foundry/cache

jobs:
  build:
    name: Build contracts
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: Cache Foundry dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.foundry/cache
            lib/
          key: ${{ runner.os }}-foundry-${{ hashFiles('foundry.toml', 'lib/**') }}
          restore-keys: |
            ${{ runner.os }}-foundry-

      - name: Install dependencies
        run: forge install --no-commit || true

      - name: Build contracts
        run: forge build --sizes

  test:
    name: Run tests
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        test-group: [unit, integration]
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: Cache Foundry dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.foundry/cache
            lib/
          key: ${{ runner.os }}-foundry-${{ hashFiles('foundry.toml', 'lib/**') }}
          restore-keys: |
            ${{ runner.os }}-foundry-

      - name: Install dependencies
        run: forge install --no-commit || true

      - name: Run unit tests
        if: matrix.test-group == 'unit'
        run: forge test --match-path "test/**/*.t.sol" --no-match-path "test/**/TokenManagementIntegration.t.sol" -v

      - name: Run integration tests
        if: matrix.test-group == 'integration'
        run: forge test --match-path "test/**/TokenManagementIntegration.t.sol" -v

  format:
    name: Check formatting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: Check Solidity formatting
        run: forge fmt --check

  # coverage:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         submodules: recursive

  #     - name: Install Foundry
  #       uses: foundry-rs/foundry-toolchain@v1
  #       with:
  #         version: nightly

  #     - name: Install dependencies
  #       run: forge install --no-commit || true

  #     - name: Run coverage
  #       run: |
  #         forge coverage --report summary --report lcov --ir-minimum
  #       continue-on-error: false
  #       env:
  #         FOUNDRY_DISABLE_NIGHTLY_WARNING: true

  #     - name: Upload coverage reports to Codecov
  #       uses: codecov/codecov-action@v4
  #       with:
  #         file: lcov.info
  #         flags: foundry
  #         name: foundry-coverage
  #         fail_ci_if_error: false
  #       env:
  #         CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  #     - name: Coverage Summary
  #       run: |
  #         echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "Coverage report generated successfully!" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         if [ -f lcov.info ]; then
  #           echo "✅ LCOV report generated" >> $GITHUB_STEP_SUMMARY
  #           echo "📊 Coverage file size: $(wc -l < lcov.info) lines" >> $GITHUB_STEP_SUMMARY
  #         else
  #           echo "❌ LCOV report not found" >> $GITHUB_STEP_SUMMARY
  #         fi

  #         # Show coverage summary from forge output
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### Forge Coverage Summary" >> $GITHUB_STEP_SUMMARY
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
  #         forge coverage --report summary --ir-minimum 2>/dev/null || echo "Coverage summary not available"
  #         echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  #     - name: Comment coverage on PR
  #       if: github.event_name == 'pull_request'
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const fs = require('fs');

  #           // Try to read coverage summary
  #           let coverageOutput = '';
  #           try {
  #             const { execSync } = require('child_process');
  #             coverageOutput = execSync('forge coverage --report summary --ir-minimum', { encoding: 'utf8' });
  #           } catch (error) {
  #             coverageOutput = 'Coverage report generation failed';
  #           }

  #           const body = `## 📊 Coverage Report

  #           \`\`\`
  #           ${coverageOutput}
  #           \`\`\`

  #           ${fs.existsSync('lcov.info') ? '✅ LCOV report generated successfully' : '❌ LCOV report not found'}
  #           `;

  #           // Find existing comment
  #           const comments = await github.rest.issues.listComments({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             issue_number: context.issue.number,
  #           });

  #           const existingComment = comments.data.find(comment =>
  #             comment.body.includes('## 📊 Coverage Report')
  #           );

  #           if (existingComment) {
  #             await github.rest.issues.updateComment({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               comment_id: existingComment.id,
  #               body: body
  #             });
  #           } else {
  #             await github.rest.issues.createComment({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               issue_number: context.issue.number,
  #               body: body
  #             });
  #           }

  # slither-analyze:
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     security-events: write
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         submodules: recursive

  #     - name: Install Foundry
  #       uses: foundry-rs/foundry-toolchain@v1
  #       with:
  #         version: nightly

  #     - name: Install dependencies
  #       run: forge install --no-commit || true

  #     - name: Build contracts
  #       run: forge build

  #     - name: Run Slither
  #       uses: crytic/slither-action@v0.4.1
  #       id: slither
  #       with:
  #         node-version: 18
  #         fail-on: none
  #         sarif: results.sarif
  #       continue-on-error: true

  #     - name: Upload SARIF file
  #       uses: github/codeql-action/upload-sarif@v3
  #       with:
  #         sarif_file: ${{ steps.slither.outputs.sarif }}

  # gas-report:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         submodules: recursive

  #     - name: Install Foundry
  #       uses: foundry-rs/foundry-toolchain@v1
  #       with:
  #         version: nightly

  #     - name: Install dependencies
  #       run: forge install --no-commit || true

  #     - name: Run tests with gas report
  #       run: forge test --gas-report > gas-report.txt

  #     - name: Comment gas report
  #       uses: actions/github-script@v7
  #       if: github.event_name == 'pull_request'
  #       with:
  #         script: |
  #           const fs = require('fs');
  #           const gasReport = fs.readFileSync('gas-report.txt', 'utf8');

  #           const body = `## Gas Report

  #           \`\`\`
  #           ${gasReport}
  #           \`\`\`
  #           `;

  #           // Find existing comment
  #           const comments = await github.rest.issues.listComments({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             issue_number: context.issue.number,
  #           });

  #           const existingComment = comments.data.find(comment =>
  #             comment.body.includes('## Gas Report')
  #           );

  #           if (existingComment) {
  #             await github.rest.issues.updateComment({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               comment_id: existingComment.id,
  #               body: body
  #             });
  #           } else {
  #             await github.rest.issues.createComment({
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               issue_number: context.issue.number,
  #               body: body
  #             });
  #           }

  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            if [ -f "package-lock.json" ]; then
              npm ci
            else
              npm install
            fi
          else
            echo "No package.json found, skipping npm install"
          fi

      - name: Check package.json scripts
        run: |
          if [ -f "package.json" ]; then
            echo "Available npm scripts:"
            npm run 2>/dev/null || echo "No scripts available"

            if npm run --silent 2>/dev/null | grep -q "lint"; then
              echo "Running lint script"
              npm run lint
            else
              echo "✅ No lint script found, skipping lint check"
              echo "Consider adding a lint script to package.json for JavaScript/TypeScript files"
            fi
          else
            echo "✅ No package.json found, skipping lint checks"
            echo "This is a Solidity project, JavaScript linting not needed"
          fi

  security-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: Check for known vulnerabilities
        run: |
          # Check for common security issues in Solidity code
          echo "Checking for common security patterns..."
          
          # Check for unsafe external calls
          if grep -r "call(" src/ --include="*.sol"; then
            echo "⚠️  Found low-level calls - please review for reentrancy"
          fi
          
          # Check for delegatecall usage
          if grep -r "delegatecall" src/ --include="*.sol"; then
            echo "⚠️  Found delegatecall usage - please review for security"
          fi
          
          # Check for assembly usage
          if grep -r "assembly" src/ --include="*.sol"; then
            echo "⚠️  Found assembly usage - please review carefully"
          fi

  build-success:
    runs-on: ubuntu-latest
    needs: [build, test, format, lint, security-check]
    if: always()
    steps:
      - name: Check all jobs
        uses: re-actors/alls-green@release/v1
        with:
          allowed-failures: security-check, lint
          jobs: ${{ toJSON(needs) }}
